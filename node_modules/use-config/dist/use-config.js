'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = require('path');
var fs = _interopDefault(require('fs'));
var pupa = _interopDefault(require('pupa'));
var pathExists = _interopDefault(require('path-exists'));
var loadJsonFile = _interopDefault(require('load-json-file'));

const isPkg = filepath => path.basename(filepath) === 'package.json';

class UseConfig {
  constructor(options = {}) {
    this.options = Object.assign({
      cwd: process.cwd(),
      files: ['{name}.config.js', 'package.json'],
      fallbackLoader(filepath) {
        return this.sync ? loadJsonFile.sync(filepath) : loadJsonFile(filepath);
      }
    }, options);

    if (typeof this.options.name !== 'string') {
      throw new TypeError('[use-config] Expect "name" to be a string');
    }

    this.loaders = [{
      test: /\.js$/,
      loader: filepath => {
        delete require.cache[filepath];
        return require(filepath);
      }
    }, {
      test: /\.json$/,
      loader: filepath => {
        const parseJson = (filepath, content) => {
          if (isPkg(filepath)) { return content[this.options.name]; }
          return content;
        };
        if (this.options.sync) {
          return loadJsonFile(filepath).then(content => parseJson(filepath, content));
        }
        return parseJson(filepath, loadJsonFile.sync(filepath));
      }
    }];
  }

  addLoader(loader) {
    this.loaders.push(loader);
    return this;
  }

  load() {
    return new Promise(function ($return, $error) {
      var loaderContext, isLast, filename, filepath, loader, config;
      loaderContext = this.getLoaderContext({ sync: false });
      {
        let index,
            _filename,
            $iterator_index__filename_1 = [this.options.files.entries()[Symbol.iterator]()];var $Loop_2_trampoline;
        return ($Loop_2_trampoline = function (q) {
          while (q) {
            if (q.then) { return void q.then($Loop_2_trampoline, $error); }try {
              if (q.pop) {
                if (q.length) { return q.pop() ? $Loop_2_exit.call(this) : q; }else { q = $Loop_2; }
              } else { q = q.call(this); }
            } catch (_exception) {
              return $error(_exception);
            }
          }
        }.bind(this))($Loop_2);

        function $Loop_2() {
          if (!($iterator_index__filename_1[1] = $iterator_index__filename_1[0].next()).done && (([index, _filename] = $iterator_index__filename_1[1].value) || true)) {
            isLast = index === this.options.files.length - 1;
            filename = pupa(_filename, { name: this.options.name });
            filepath = path.resolve(this.options.cwd, filename);
            return Promise.resolve(pathExists(filepath)).then(function ($await_4) {
              try {

                if (!$await_4) {
                  if (isLast) {
                    return $return({});
                  }
                  return $Loop_2;
                }
                loader = (...args) => new Promise(function ($return, $error) {
                  return $return(this.findLoader(filepath).call(loaderContext, ...args));
                }.bind(this));
                return Promise.resolve(loader(filepath)).then(function ($await_5) {
                  try {
                    config = $await_5;


                    if (typeof config === 'undefined') {
                      if (isPkg(filepath)) {
                        if (isLast) {
                          return $return({});
                        }
                        return $Loop_2;
                      }
                      return $return({
                        path: filepath,
                        config
                      });
                    }

                    return $return({
                      config,
                      path: filepath
                    });
                  } catch ($boundEx) {
                    return $error($boundEx);
                  }
                }.bind(this), $error);
              } catch ($boundEx) {
                return $error($boundEx);
              }
            }.bind(this), $error);
          } else { return [1]; }
        }
      }

      function $Loop_2_exit() {
        return $return();
      }
    }.bind(this));
  }

  loadSync() {
    const loaderContext = this.getLoaderContext({ sync: true });
    for (const [index, _filename] of this.options.files.entries()) {
      const isLast = index === this.options.files.length - 1;
      const filename = pupa(_filename, { name: this.options.name });
      const filepath = path.resolve(this.options.cwd, filename);
      if (!fs.existsSync(filepath)) {
        if (isLast) {
          return {};
        }
        continue;
      }
      const loader = this.findLoader(filepath);
      const config = loader.call(loaderContext, filepath);

      if (typeof config === 'undefined') {
        // When `config` is undefined
        // We should only continue searching next file
        // If current file is `package.json`
        if (isPkg(filepath)) {
          if (isLast) {
            return {};
          }
          continue;
        }
        return {
          path: filepath,
          config
        };
      }

      if (config.then) {
        throw new Error(`[use-config] You're using the .loadSync method but the loader returns a Promise!`);
      }

      return { config, path: filepath };
    }
  }

  findLoader(filepath) {
    const matched = this.loaders.filter(loader => loader.test.test(filepath))[0];
    return matched && matched.loader || this.options.fallbackLoader;
  }

  getLoaderContext({ sync }) {
    return {
      options: this.options,
      sync,
      loadJsonFile,
      pathExists
    };
  }
}

module.exports = UseConfig;
